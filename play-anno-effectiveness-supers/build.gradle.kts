dependencies {
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-aop")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("io.github.resilience4j:resilience4j-spring-boot3")
    compileOnly("org.projectlombok:lombok")
    annotationProcessor("org.springframework.boot:spring-boot-configuration-processor")
    annotationProcessor("org.projectlombok:lombok")
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

tasks {
    create("generateDemos") {
        val basePkg = "org.example.ae.supers"
        doLast {
            mkdirs(basePkg)
            val cases = generateCases()
            cases.forEach { generateDemo(basePkg, it) }
            cases.forEach { generateCaseRunner(basePkg, it) }
        }
    }
}

fun mkdirs(basePkg: String) {
    val javaPkgPath = "src/main/java/${basePkg.replace(".", "/")}/demos"
    mkdir(javaPkgPath)
    val kotlinPkgPath = "src/main/kotlin/${basePkg.replace(".", "/")}/demos"
    mkdir(kotlinPkgPath)
}

fun generateCases(): List<Case> {
    val cases = mutableListOf<Case>()
    for (hasClassAnnotationOnSuper in listOf(true, false)) {
        for (originMethodInSuper in OriginMethodInSuper.values()) {
            for (fallbackInSuper in FallbackInSuper.values()) {
                for (hasClassAnnotationOnSub in listOf(true, false)) {
                    for (originMethodInSub in OriginMethodInSub.values()) {
                        if (!originMethodInSuper.isNormal && originMethodInSub == OriginMethodInSub.None) {
                            // 无效组合：父类声明抽象源方法，子类必须实现
                            continue
                        }
                        for (hasFallbackInSub in listOf(true, false)) {
                            if (!hasFallbackInSub && fallbackInSuper == FallbackInSuper.Abstract) {
                                // 无效组合：父类声明抽象 fallback 方法，子类必须实现
                                continue
                            }
                            cases.add(
                                Case(
                                    sn = String.format("%03d", cases.size + 1),
                                    hasClassAnnotationOnSuper = hasClassAnnotationOnSuper,
                                    originMethodInSuper = originMethodInSuper,
                                    fallbackInSuper = fallbackInSuper,
                                    hasClassAnnotationOnSub = hasClassAnnotationOnSub,
                                    originMethodInSub = originMethodInSub,
                                    hasFallbackInSub = hasFallbackInSub,
                                )
                            )
                        }
                    }
                }
            }
        }
    }
    return cases
}

fun generateDemo(basePkg: String, case: Case) {
    logger.lifecycle("generateDemo: $case")
    val javaPkgPath = "src/main/java/${basePkg.replace(".", "/")}/demos"
    val kotlinPkgPath = "src/main/kotlin/${basePkg.replace(".", "/")}/demos"
    generateJavaSuper(javaPkgPath, basePkg, case, "Java")
    generateJavaDemo(javaPkgPath, basePkg, case, "Java")
    generateJavaSuper(javaPkgPath, basePkg, case, "Kotlin")
    generateKotlinDemo(kotlinPkgPath, basePkg, case, "Java")
    generateKotlinSuper(kotlinPkgPath, basePkg, case, "Java")
    generateJavaDemo(javaPkgPath, basePkg, case, "Kotlin")
    generateKotlinSuper(kotlinPkgPath, basePkg, case, "Kotlin")
    generateKotlinDemo(kotlinPkgPath, basePkg, case, "Kotlin")
}

fun generateJavaSuper(pkgPath: String, basePkg: String, case: Case, subLang: String) {
    val superName = "Case${case.sn}JavaSuperFor$subLang"
    val file = File("$pkgPath/$superName.java")
    file.writeText(
        """
                    |// Generated by generateDemo task, DO NOT MODIFY
                    |package $basePkg.demos;
                    |
        """.trimMargin()
    )
    if (case.hasClassAnnotationOnSuper || case.originMethodInSuper.hasAnnotation) {
        file.appendText(
            """
                    |
                    |import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |import $basePkg.biz.DemoCase;
        """.trimMargin()
    )
    if (
        case.originMethodInSuper.isNormal ||
        case.originMethodInSuper.hasAnnotation ||
        case.fallbackInSuper != FallbackInSuper.None
    ) {
        file.appendText(
            """
                    |
                    |import org.jetbrains.annotations.NotNull;
                    |import org.jetbrains.annotations.Nullable;
                    |
           """.trimMargin()
        )
    }
    if (case.fallbackInSuper == FallbackInSuper.Normal) {
        file.appendText(
            """
                    |
                    |import static $basePkg.biz.DemoCase.EffectiveAnnotation.*;
                    |import static $basePkg.biz.DemoCase.EffectiveFallback.FallbackInSuper;
                    |import static $basePkg.biz.Greeting.doFallback;
            """.trimMargin()
        )
    }
    if (case.originMethodInSuper.isNormal) {
        file.appendText(
            """
                    |
                    |import static $basePkg.biz.Greeting.doGreeting;
            """.trimMargin()
        )
    }
    file.appendText("\n")
    if (case.hasClassAnnotationOnSuper) {
        file.appendText(
            """
                    |
                    |@CircuitBreaker(name = "demo", fallbackMethod = "superClassFallback")
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |public abstract class $superName implements DemoCase {
                    |
        """.trimMargin()
    )
    if (case.originMethodInSuper.hasAnnotation) {
        file.appendText(
            """
                    |
                    |    @CircuitBreaker(name = "demo", fallbackMethod = "superMethodFallback")
            """.trimMargin()
        )
    }
    if (case.originMethodInSuper.isNormal) {
        file.appendText(
            """
                    |
                    |    @NotNull
                    |    @Override
                    |    public String greeting(@Nullable String name) {
                    |        return "super:" + doGreeting(name);
                    |    }
                    |
                """.trimMargin()
        )
    } else if (case.originMethodInSuper.hasAnnotation) {
        file.appendText(
            """
                    |
                    |    @NotNull
                    |    public abstract String greeting(@Nullable String name);
                    |
                """.trimMargin()
        )
    }
    if (case.fallbackInSuper == FallbackInSuper.Normal) {
        file.appendText(
            """
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public String superClassFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return ClassAnnotationOnSuper + ":" + FallbackInSuper + ":" + doFallback(name, thr);
                    |    }
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public String superMethodFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return MethodAnnotationInSuper + ":" + FallbackInSuper + ":" + doFallback(name, thr);
                    |    }
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public String classFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return ClassAnnotationOnSub + ":" + FallbackInSuper + ":" + doFallback(name, thr);
                    |    }
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public String methodFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return MethodAnnotationInSub + ":" + FallbackInSuper + ":" + doFallback(name, thr);
                    |    }
                    |
            """.trimMargin()
        )
    } else if (case.fallbackInSuper == FallbackInSuper.Abstract) {
        file.appendText(
            """
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public abstract String superClassFallback(@Nullable String name, @Nullable Throwable thr);
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public abstract String superMethodFallback(@Nullable String name, @Nullable Throwable thr);
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public abstract String classFallback(@Nullable String name, @Nullable Throwable thr);
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull
                    |    public abstract String methodFallback(@Nullable String name, @Nullable Throwable thr);
                    |
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |}
                    |
        """.trimMargin()
    )
}

fun generateJavaDemo(pkgPath: String, basePkg: String, case: Case, superLang: String) {
    val className = "Case${case.sn}${superLang}SuperJavaDemo"
    val file = File("$pkgPath/$className.java")
    file.writeText(
        """
                    |// Generated by generateDemo task, DO NOT MODIFY
                    |package $basePkg.demos;
                    |
        """.trimMargin()
    )
    if (case.hasClassAnnotationOnSub || case.originMethodInSub.hasAnnotation) {
        file.appendText(
            """
                    |
                    |import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |import org.jetbrains.annotations.NotNull;
        """.trimMargin()
    )
    if (case.originMethodInSub != OriginMethodInSub.None || case.hasFallbackInSub) {
        file.appendText(
            """
                    |
                    |import org.jetbrains.annotations.Nullable;
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |import org.springframework.stereotype.Component;
                    |
        """.trimMargin()
    )
    if (case.hasFallbackInSub) {
        file.appendText(
            """
                    |
                    |import static $basePkg.biz.DemoCase.EffectiveAnnotation.*;
                    |import static $basePkg.biz.DemoCase.EffectiveFallback.FallbackInSub;
                    |import static $basePkg.biz.Greeting.doFallback;
            """.trimMargin()
        )
    }
    if (case.originMethodInSub != OriginMethodInSub.None) {
        file.appendText(
            """
                    |
                    |import static $basePkg.biz.Greeting.doGreeting;
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |
                    |@Component
        """.trimMargin()
    )
    if (case.hasClassAnnotationOnSub) {
        file.appendText(
            """
                    |
                    |@CircuitBreaker(name = "demo", fallbackMethod = "classFallback")
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |public class $className extends Case${case.sn}${superLang}SuperForJava {
                    |
                    |    @NotNull
                    |    @Override
                    |    public String sn() {
                    |        return "${case.sn}";
                    |    }
                    |
                    |    @Override
                    |    public boolean hasClassAnnotationOnSuper() {
                    |        return ${case.hasClassAnnotationOnSuper};
                    |    }
                    |
                    |    @NotNull
                    |    @Override
                    |    public OriginMethodInSuper originMethodInSuper() {
                    |        return OriginMethodInSuper.${case.originMethodInSuper.name};
                    |    }
                    |
                    |    @NotNull
                    |    @Override
                    |    public FallbackInSuper fallbackInSuper() {
                    |        return FallbackInSuper.${case.fallbackInSuper.name};
                    |    }
                    |
                    |    @Override
                    |    public boolean hasClassAnnotationOnSub() {
                    |        return ${case.hasClassAnnotationOnSub};
                    |    }
                    |
                    |    @NotNull
                    |    @Override
                    |    public OriginMethodInSub originMethodInSub() {
                    |        return OriginMethodInSub.${case.originMethodInSub.name};
                    |    }
                    |
                    |    @Override
                    |    public boolean hasFallbackInSub() {
                    |        return ${case.hasFallbackInSub};
                    |    }
                    |
        """.trimMargin()
    )
    if (case.originMethodInSub.hasAnnotation) {
        file.appendText(
            """
                    |
                    |    @CircuitBreaker(name = "demo", fallbackMethod = "methodFallback")
            """.trimMargin()
        )
    }
    if (case.originMethodInSub != OriginMethodInSub.None) {
        file.appendText(
            """
                    |
                    |    @NotNull
                    |    @Override
                    |    public String greeting(@Nullable String name) {
                    |        return doGreeting(name);
                    |    }
                    |
            """.trimMargin()
        )
    }
    if (case.hasFallbackInSub) {
        val optionalOverrideAnno =
            if (case.fallbackInSuper != FallbackInSuper.None) "\n    @Override" else ""
        file.appendText(
            """
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull$optionalOverrideAnno
                    |    public String superClassFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return ClassAnnotationOnSuper + ":" + FallbackInSub + ":" + doFallback(name, thr);
                    |    }
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull$optionalOverrideAnno
                    |    public String superMethodFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return MethodAnnotationInSuper + ":" + FallbackInSub + ":" + doFallback(name, thr);
                    |    }
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull$optionalOverrideAnno
                    |    public String classFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return ClassAnnotationOnSub + ":" + FallbackInSub + ":" + doFallback(name, thr);
                    |    }
                    |
                    |    @SuppressWarnings("unused")
                    |    @NotNull$optionalOverrideAnno
                    |    public String methodFallback(@Nullable String name, @Nullable Throwable thr) {
                    |        return MethodAnnotationInSub + ":" + FallbackInSub + ":" + doFallback(name, thr);
                    |    }
                    |
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |}
                    |
        """.trimMargin()
    )
}

fun generateKotlinSuper(pkgPath: String, basePkg: String, case: Case, subLang: String) {
    val superName = "Case${case.sn}KotlinSuperFor$subLang"
    val file = File("$pkgPath/$superName.kt")
    file.writeText(
        """
                    |// Generated by generateDemo task, DO NOT MODIFY
                    |package $basePkg.demos
                    |
        """.trimMargin()
    )
    if (case.hasClassAnnotationOnSuper || case.originMethodInSuper.hasAnnotation) {
        file.appendText(
            """
                    |
                    |import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |import $basePkg.biz.DemoCase
        """.trimMargin()
    )
    if (case.fallbackInSuper == FallbackInSuper.Normal) {
        file.appendText(
            """
                    |
                    |import $basePkg.biz.DemoCase.EffectiveAnnotation.*
                    |import $basePkg.biz.DemoCase.EffectiveFallback.FallbackInSuper
                    |import $basePkg.biz.Greeting.doFallback
            """.trimMargin()
        )
    }
    if (case.originMethodInSuper.isNormal) {
        file.appendText(
            """
                    |
                    |import $basePkg.biz.Greeting.doGreeting
            """.trimMargin()
        )
    }
    file.appendText("\n")
    if (case.hasClassAnnotationOnSuper) {
        file.appendText(
            """
                    |
                    |@CircuitBreaker(name = "demo", fallbackMethod = "superClassFallback")
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |abstract class $superName : DemoCase
        """.trimMargin()
    )
    val hasClassBody = case.originMethodInSuper.isNormal ||
            case.originMethodInSuper.hasAnnotation ||
            case.fallbackInSuper != FallbackInSuper.None
    if (hasClassBody) {
        file.appendText(" {\n")
    } else {
        file.appendText("\n")
    }
    if (case.originMethodInSuper.hasAnnotation) {
        file.appendText(
            """
                    |
                    |    @CircuitBreaker(name = "demo", fallbackMethod = "superMethodFallback")
            """.trimMargin()
        )
    }
    if (case.originMethodInSuper.isNormal) {
        file.appendText(
            """
                    |
                    |    override fun greeting(name: String?): String {
                    |        return "super:${"$"}{doGreeting(name)}"
                    |    }
                    |
                """.trimMargin()
        )
    } else if (case.originMethodInSuper.hasAnnotation) {
        file.appendText(
            """
                    |
                    |    abstract override fun greeting(name: String?): String
                    |
                """.trimMargin()
        )
    }
    if (case.fallbackInSuper == FallbackInSuper.Normal) {
        val optionalOpenKeyword = if (case.hasFallbackInSub) "open " else ""
        file.appendText(
            """
                    |
                    |    ${optionalOpenKeyword}fun superClassFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}ClassAnnotationOnSuper:${"$"}FallbackInSuper:${"$"}{doFallback(name, thr)}"
                    |    }
                    |
                    |    ${optionalOpenKeyword}fun superMethodFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}MethodAnnotationInSuper:${"$"}FallbackInSuper:${"$"}{doFallback(name, thr)}"
                    |    }
                    |
                    |    ${optionalOpenKeyword}fun classFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}ClassAnnotationOnSub:${"$"}FallbackInSuper:${"$"}{doFallback(name, thr)}"
                    |    }
                    |
                    |    ${optionalOpenKeyword}fun methodFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}MethodAnnotationInSub:${"$"}FallbackInSuper:${"$"}{doFallback(name, thr)}"
                    |    }
                    |
            """.trimMargin()
        )
    } else if (case.fallbackInSuper == FallbackInSuper.Abstract) {
        file.appendText(
            """
                    |
                    |    abstract fun superClassFallback(name: String?, thr: Throwable?): String
                    |
                    |    abstract fun superMethodFallback(name: String?, thr: Throwable?): String
                    |
                    |    abstract fun classFallback(name: String?, thr: Throwable?): String
                    |
                    |    abstract fun methodFallback(name: String?, thr: Throwable?): String
                    |
            """.trimMargin()
        )
    }
    if (hasClassBody) {
        file.appendText("\n}\n")
    }
}

fun generateKotlinDemo(pkgPath: String, basePkg: String, case: Case, superLang: String) {
    val className = "Case${case.sn}${superLang}SuperKotlinDemo"
    val file = File("$pkgPath/$className.kt")
    file.writeText(
        """
                    |// Generated by generateDemo task, DO NOT MODIFY
                    |package $basePkg.demos
                    |
        """.trimMargin()
    )
    if (case.hasClassAnnotationOnSub || case.originMethodInSub.hasAnnotation) {
        file.appendText(
            """
                    |
                    |import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |import $basePkg.biz.DemoCase
        """.trimMargin()
    )
    if (case.hasFallbackInSub) {
        file.appendText(
            """
                    |
                    |import $basePkg.biz.DemoCase.EffectiveAnnotation.*
                    |import $basePkg.biz.DemoCase.EffectiveFallback.FallbackInSub
                    |import $basePkg.biz.Greeting.doFallback
            """.trimMargin()
        )
    }
    if (case.originMethodInSub != OriginMethodInSub.None) {
        file.appendText(
            """
                    |
                    |import $basePkg.biz.Greeting.doGreeting
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |import org.springframework.stereotype.Component
                    |
                    |@Component
        """.trimMargin()
    )
    if (case.hasClassAnnotationOnSub) {
        file.appendText(
            """
                    |
                    |@CircuitBreaker(name = "demo", fallbackMethod = "classFallback")
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |class $className : Case${case.sn}${superLang}SuperForKotlin() {
                    |
                    |    override fun sn(): String {
                    |        return "${case.sn}"
                    |    }
                    |
                    |    override fun hasClassAnnotationOnSuper(): Boolean {
                    |        return ${case.hasClassAnnotationOnSuper}
                    |    }
                    |
                    |    override fun originMethodInSuper(): DemoCase.OriginMethodInSuper {
                    |        return DemoCase.OriginMethodInSuper.${case.originMethodInSuper.name}
                    |    }
                    |
                    |    override fun fallbackInSuper(): DemoCase.FallbackInSuper {
                    |        return DemoCase.FallbackInSuper.${case.fallbackInSuper.name}
                    |    }
                    |
                    |    override fun hasClassAnnotationOnSub(): Boolean {
                    |        return ${case.hasClassAnnotationOnSub}
                    |    }
                    |
                    |    override fun originMethodInSub(): DemoCase.OriginMethodInSub {
                    |        return DemoCase.OriginMethodInSub.${case.originMethodInSub.name}
                    |    }
                    |
                    |    override fun hasFallbackInSub(): Boolean {
                    |        return ${case.hasFallbackInSub}
                    |    }
                    |
        """.trimMargin()
    )
    if (case.originMethodInSub.hasAnnotation) {
        file.appendText(
            """
                    |
                    |    @CircuitBreaker(name = "demo", fallbackMethod = "methodFallback")
            """.trimMargin()
        )
    }
    if (case.originMethodInSub != OriginMethodInSub.None) {
        file.appendText(
            """
                    |
                    |    override fun greeting(name: String?): String {
                    |        return doGreeting(name)
                    |    }
                    |
            """.trimMargin()
        )
    }
    if (case.hasFallbackInSub) {
        val optionalOverrideKeyword =
            if (case.fallbackInSuper != FallbackInSuper.None) "override " else ""
        file.appendText(
            """
                    |
                    |    ${optionalOverrideKeyword}fun superClassFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}ClassAnnotationOnSuper:${"$"}FallbackInSub:${"$"}{doFallback(name, thr)}"
                    |    }
                    |
                    |    ${optionalOverrideKeyword}fun superMethodFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}MethodAnnotationInSuper:${"$"}FallbackInSub:${"$"}{doFallback(name, thr)}"
                    |    }
                    |
                    |    ${optionalOverrideKeyword}fun classFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}ClassAnnotationOnSub:${"$"}FallbackInSub:${"$"}{doFallback(name, thr)}"
                    |    }
                    |
                    |    ${optionalOverrideKeyword}fun methodFallback(name: String?, thr: Throwable?): String {
                    |        return "${"$"}MethodAnnotationInSub:${"$"}FallbackInSub:${"$"}{doFallback(name, thr)}"
                    |    }
            """.trimMargin()
        )
    }
    file.appendText(
        """
                    |
                    |}
                    |
        """.trimMargin()
    )
}

fun generateCaseRunner(basePkg: String, case: Case) {
    val className = "Case${case.sn}Runner"
    val pkgPath = "src/main/java/${basePkg.replace(".", "/")}/demos"
    val file = File("$pkgPath/$className.java")
    file.writeText(
        """
            package $basePkg.demos;

            import jakarta.annotation.Resource;
            import lombok.extern.slf4j.Slf4j;
            import $basePkg.biz.DemoCase;
            import org.springframework.boot.CommandLineRunner;
            import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
            import org.springframework.core.Ordered;
            import org.springframework.stereotype.Component;

            import java.util.Objects;

            import static $basePkg.biz.Run.detectEffectiveness;

            @ConditionalOnProperty(name = "run.only", havingValue = "case${case.sn}", matchIfMissing = true)
            @Component
            @Slf4j
            public class Case${case.sn}Runner implements CommandLineRunner, Ordered {
                @Resource(name = "case${case.sn}JavaSuperJavaDemo")
                private DemoCase javaSuperJavaDemo;
                @Resource(name = "case${case.sn}JavaSuperKotlinDemo")
                private DemoCase javaSuperKotlinDemo;
                @Resource(name = "case${case.sn}KotlinSuperJavaDemo")
                private DemoCase kotlinSuperJavaDemo;
                @Resource(name = "case${case.sn}KotlinSuperKotlinDemo")
                private DemoCase kotlinSuperKotlinDemo;

                @Override
                public int getOrder() {
                    return Integer.parseInt(javaSuperJavaDemo.sn());
                }

                @Override
                public void run(String... args) {
                    log.info("case result: {}", detectCasesEffectiveness());
                }

                private String detectCasesEffectiveness() {
                    var jjResult = detectEffectiveness(javaSuperJavaDemo);
                    var jkResult = detectEffectiveness(javaSuperKotlinDemo);
                    var kjResult = detectEffectiveness(kotlinSuperJavaDemo);
                    var kkResult = detectEffectiveness(kotlinSuperKotlinDemo);
                    if (Objects.equals(jjResult, jkResult) && Objects.equals(jkResult, kjResult) && Objects.equals(kjResult, kkResult)) {
                        return jjResult.csvLine();
                    }
                    throw new IllegalStateException("case effectiveness not match");
                }
            }

        """.trimIndent()
    )
}

data class Case(
    val sn: String,
    val hasClassAnnotationOnSuper: Boolean,
    val originMethodInSuper: OriginMethodInSuper,
    val fallbackInSuper: FallbackInSuper,
    val hasClassAnnotationOnSub: Boolean,
    val originMethodInSub: OriginMethodInSub,
    val hasFallbackInSub: Boolean,
)

enum class OriginMethodInSuper(val isNormal: Boolean, val hasAnnotation: Boolean) {
    NormalWithAnnotation(true, true),
    NormalWithoutAnnotation(true, false),
    AbstractWithAnnotation(false, true),
    AbstractWithoutAnnotation(false, false),
    ;
}

enum class FallbackInSuper {
    Normal,
    Abstract,
    None,
    ;
}

enum class OriginMethodInSub(val hasAnnotation: Boolean) {
    WithAnnotation(true),
    WithoutAnnotation(false),
    None(false),
    ;
}
